<?php
/*
 * @(#)Symbol.php
 * Copyright Â© 2025 Werner Randelshofer, Switzerland. MIT License.
 */

/**
 * Typesafe enum of Symbols generated by the Parser.
 */
enum Symbol:string {

    /**
     * Terminal symbols.
     */
   case NOP="NOP";
   case MOVE="move";

    // Note: Ordering of the enum constants is significant.
    // Class PermutationNode implies that PR < PU < PF < PL < PD < PB.
  case FACE_R="permR";
  case FACE_U="permU";
  case FACE_F="permF";
  case FACE_L="permL";
  case FACE_D="permD";
  case FACE_B="permB";

  case PERMUTATION_PLUS="permPlus";
  case PERMUTATION_MINUS="permMinus";
  case PERMUTATION_PLUSPLUS="permPlusPlus";
  case PERMUTATION_BEGIN="permBegin";
  case PERMUTATION_END="permEnd";
  case PERMUTATION_DELIMITER="permDelim";
  case DELIMITER="delimiter";
  case INVERSION_BEGIN="inversionBegin";
  case INVERSION_END="inversionEnd";
  case INVERSION_OPERATOR="invertor";
  case REFLECTION_BEGIN="reflectionBegin";
  case REFLECTION_END="reflectionEnd";
  case REFLECTION_OPERATOR="reflector";
  case GROUPING_BEGIN="groupingBegin";
  case GROUPING_END="groupingEnd";
  case REPETITION_BEGIN="repetitionBegin";
  case REPETITION_END="repetitionEnd";
  case REPETITION_DELIMITER="repetitionDelim";
  case REPETITION_OPERATOR="repetitionOperator";
  case COMMUTATION_BEGIN="commutationBegin";
  case COMMUTATION_END="commutationEnd";
  case COMMUTATION_DELIMITER="commutationDelim";
  case COMMUTATION_OPERATOR="commutationOperator";
  case CONJUGATION_BEGIN="conjugationBegin";
  case CONJUGATION_END="conjugationEnd";
  case CONJUGATION_DELIMITER="conjugationDelim";
  case CONJUGATION_OPERATOR="conjugationOperator";
  case ROTATION_BEGIN="rotationBegin";
  case ROTATION_END="rotationEnd";
  case ROTATION_DELIMITER="rotationDelim";
  case ROTATION_OPERATOR="rotationOperator";
  case MACRO="macro";
  case MULTILINE_COMMENT_BEGIN="commentMultiLineBegin";
  case MULTILINE_COMMENT_END="commentMultiLineEnd";
  case SINGLELINE_COMMENT_BEGIN="commentSingleLineBegin";

    // Composite symbols.

  case  COMMUTATION="commutation";
    case CONJUGATION="conjugation";
    case GROUPING="grouping";
    case INVERSION="inversion";
    case PERMUTATION="permutation";

    case REFLECTION="reflection";
    case REPETITION="repetition";
    case ROTATION="rotation";
    case COMMENT="comment";
    case PRIMARY="primary";
    case STATEMENT="statement";
    case SEQUENCE="sequence";



    public static function isTerminalSymbol(Symbol $symbol) {
        return $this->subSymbols == null;
    }

    public static function isSubSymbol(Symbol $compositeSymbol, Symbol $s) {
        return $this->s == $this || $this->subSymbols->contains($s);
    }

    public static function /*Set<Symbol>*/ getSubSymbols() {
        return $this->subSymbols;
    }

    public static function getName() {
        return $this->name;
    }

    public static function getAlternativeName() {
        return $this->alternativeName;
    }

    public static function getCompositeSymbol() {
        return $this->getCompositeSymbolMap()->get($this);

    }

    public static function toString() {
        return $this->name;
    }

    public static function/*Map<string, Symbol>*/ getSymbolValueSet() {
        if (Symbol::$symbolValueSet == null) {
            /*HashMap<string, Symbol>*/ $m = array();
            foreach (Symbol::values() as $s) {
                $m[$s->name]= $s;
                if ($s->alternativeName != null) {
                    $m[$s->alternativeName]=$s;
                }
            }
            Symbol::$symbolValueSet = $m;
        }
        return Symbol::$symbolValueSet;
    }

    public static function/*Map<Symbol.getName(), Symbol>*/ getCompositeSymbolMap() {
        if (Symbol::$compositeSymbolMap == null) {
            /*HashMap<Symbol, Symbol>*/ $m = array();
            foreach (Symbol::values() as $s) {
                $m[$s->getName()] = $s;
            }
            foreach (Symbol::values() as $s) {
                foreach ($s->$subSymbols as $subSymbol) {
                    if ($subSymbol->subSymbols->isEmpty()) {
                        $m[$subSymbol->getName()]= $s;
                    }
                }
            }
            Symbol::$compositeSymbolMap = $m;
        }
        return Symbol::$compositeSymbolMap;
    }

    public static function isBegin(Symbol $s) {
        switch (s) {
            case CONJUGATION_BEGIN:
            case COMMUTATION_BEGIN:
            case ROTATION_BEGIN:
            case PERMUTATION_BEGIN:
            case INVERSION_BEGIN:
            case REFLECTION_BEGIN:
            case GROUPING_BEGIN:
            case MULTILINE_COMMENT_BEGIN:
            case SINGLELINE_COMMENT_BEGIN:
                return true;
            default:
                return false;
        }
    }

    public static function isOperator(Symbol $s) {
        switch (s) {
            case CONJUGATION_OPERATOR:
            case COMMUTATION_OPERATOR:
            case ROTATION_OPERATOR:
            case INVERSION_OPERATOR:
            case REFLECTION_OPERATOR:
            case REPETITION_OPERATOR:
                return true;
            default:
                return false;
        }
    }

    public static function isDelimiter( Symbol $s) {
        switch ($s) {
            case ROTATION_DELIMITER:
            case CONJUGATION_DELIMITER:
            case COMMUTATION_DELIMITER:
                return true;
            default:
                return false;
        }
    }

    public static function isEnd( Symbol $s) {
        switch ($s) {
            case CONJUGATION_END:
            case COMMUTATION_END:
            case PERMUTATION_END:
            case ROTATION_END:
            case INVERSION_END:
            case REFLECTION_END:
            case GROUPING_END:
            case MULTILINE_COMMENT_END:
                return true;
            default:
                return false;
        }
    }

    public static function isFaceSymbol( Symbol $s) {
        switch ($s) {
            case FACE_R:
            case FACE_U:
            case FACE_F:
            case FACE_L:
            case FACE_D:
            case FACE_B:
                return true;
            default:
                return false;
        }
    }

    public static function isPermutationSign( Symbol $s) {
        switch ($s) {
            case PERMUTATION_PLUS:
            case PERMUTATION_PLUSPLUS:
            case PERMUTATION_MINUS:
                return true;
            default:
                return false;
        }
    }

    public static function values() {
        return array(
        NOP
        );
    }

}
